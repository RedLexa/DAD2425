package dadkvs.server;

import java.util.ArrayList;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.CollectorStreamObserver;
import dadkvs.util.GenericResponseCollector;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;


public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

	DadkvsServerState server_state;
	DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_stubs;
	boolean stubs_created;
	int n_servers = 5;
	int config = 0; // config is 0 for now, when we add it we can change it

	public DadkvsMainServiceImpl(DadkvsServerState state) {
		this.server_state = state;
		this.stubs_created = false;
	}

	@Override
	public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
		// for debug purposes
		System.out.println("Receiving read request:" + request);

		int reqid = request.getReqid();
		int key = request.getKey();
		VersionedValue vv = this.server_state.store.read(key);

		DadkvsMain.ReadReply response = DadkvsMain.ReadReply.newBuilder()
				.setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		// this is used to create the stubs only once whenever all the servers are up,
		// its put here to avoid servers being down
		if (!stubs_created) {
			this.stubs_created = true;
			this.initComms();
		}
		// for debug purposes
		System.out.println("Receiving commit request:" + request);

		server_state.responseObserver.put(request.getReqid(), responseObserver);
		server_state.request_list.put(request.getReqid(), request);

		if (server_state.i_am_leader && server_state.request_list.containsKey(request.getReqid())) {
			System.out.println("SOU O LIDER #################");
			// comecar uma fase 1, olhando para o seu seq_number interno e verificando qual
			// deve o proximo index a executar, propondo-o dessa forma

			// server_state.req_to_propose = last_requestid_received; TO-DO: arranjar
			// maneira de saber sempre qual a transacao que o lider acha que devia ser
			// executada

			server_state.timestamp++;
			DadkvsPaxos.PhaseOneRequest.Builder phase_one_request = DadkvsPaxos.PhaseOneRequest.newBuilder();
			phase_one_request.setPhase1Config(this.config)
					.setPhase1Index(server_state.next_req)
					.setPhase1Timestamp(server_state.timestamp).build();
			// talvez esta logica daqui para baixo deva estar na parte do paxos?
			ArrayList<DadkvsPaxos.PhaseOneReply> phase_one_responses = new ArrayList<DadkvsPaxos.PhaseOneReply>();
			GenericResponseCollector<DadkvsPaxos.PhaseOneReply> phase_one_collector = new GenericResponseCollector<DadkvsPaxos.PhaseOneReply>(
					phase_one_responses, n_servers);
			for (int i = 0; i < n_servers; i++) {
				if (server_state.my_id == i) {
					// this.server_state.phase_two_requests.put(request.getReqid(),
					// phase_two_request.build());
					continue;
				}
				CollectorStreamObserver<DadkvsPaxos.PhaseOneReply> phase_one_observer = new CollectorStreamObserver<DadkvsPaxos.PhaseOneReply>(
						phase_one_collector);
				async_stubs[i].phaseone(phase_one_request.build(), phase_one_observer);
			}

			int all_responses = n_servers - 1;     // TODO: mudar para while
			int accepts_needed = (n_servers / 2);  // maioria considerando o nosso proprio pedido
			int accepts_received = 0;
			int highest_received_timestamp = -1;
			int messages_needed = accepts_needed;
			while(accepts_received < accepts_needed || accepts_received < all_responses){
				accepts_received = 0;    // podemos mudar a logica mas fiz so copy paste
				phase_one_collector.waitForTarget(messages_needed);
				for (DadkvsPaxos.PhaseOneReply phase_one_reply : phase_one_responses) {
					if (phase_one_reply.getPhase1Accepted()) {
						accepts_received++; // Count accepted responses
					}
					if (phase_one_reply.getPhase1Value() != -1) {
						if (highest_received_timestamp < phase_one_reply.getPhase1Timestamp()) {
							server_state.req_to_propose = phase_one_reply.getPhase1Value();
							highest_received_timestamp = phase_one_reply.getPhase1Timestamp();
						}
				}
				// se recebemos um quorum de mensagens e do quorum de mensagens ainda faltam
				// (accepts needed - accepts recieved) accepts -> precisamos de esperar por mais
				// esse numero de mensagens
				messages_needed = messages_needed + accepts_needed - accepts_received;
			}

			System.out.println("Quorum reached with " + accepts_received + " acceptances.");
			this.server_state.next_req++;

		} /*else{
			System.out.println("Panic...error phase_one ing");
		}*/
	}

	private void initComms() {
		int n_servers = 5;
		String[] targets;
		targets = new String[n_servers];
		for (int i = 0; i < n_servers; i++) {
			int target_port = this.server_state.base_port + i;
			targets[i] = new String();
			targets[i] = "localhost" + ":" + target_port;
		}
		// Let us use plaintext communication because we do not have certificates
		ManagedChannel[] channels = new ManagedChannel[n_servers];

		for (int i = 0; i < n_servers; i++) {
			channels[i] = ManagedChannelBuilder.forTarget(targets[i]).usePlaintext().build();
		}

		async_stubs = new DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[n_servers];

		for (int i = 0; i < n_servers; i++) {
			async_stubs[i] = DadkvsPaxosServiceGrpc.newStub(channels[i]);
		}
	}
	// public static void executeCommit(int reqid, DadkvsServerState server_state){

    //     System.out.println("handle_all_possible_requests");
    //     System.out.println(server_state.next_req + "==" + reqid + "&&" + server_state.request_list.containsKey(reqid) + "&&" + server_state.phase_two_requests.containsKey(reqid));
    //     // enquanto o reqid for o do proximo pedido e se tivermos o pedido do cliente e do 2phase vamos processar a transacao
    //     while(server_state.request_list.containsKey(reqid) && server_state.phase_two_requests.containsKey(reqid) && server_state.phase_two_requests.get(reqid).getPhase2Value() == server_state.next_req) {

    //         DadkvsMain.CommitRequest request = server_state.request_list.get(reqid);
    //         DadkvsPaxos.PhaseTwoRequest p2request = server_state.phase_two_requests.get(reqid);
    //         int key1 = request.getKey1();
    //         int version1 = request.getVersion1();
    //         int key2 = request.getKey2();
    //         int version2 = request.getVersion2();
    //         int writekey = request.getWritekey();
    //         int writeval = request.getWriteval();

    //         // for debug purposes
    //         System.out.println("reqid " + reqid + " key1 " + key1 + " v1 " + version1 + " k2 " + key2 + " v2 " + version2 + " wk " + writekey + " writeval " + writeval);

    //         // append pedido a lista
    //         // this.timestamp++;  so interessa para o ldier
    //         TransactionRecord txrecord = new TransactionRecord(key1, version1, key2, version2, writekey, writeval, p2request.getPhase2Timestamp());
    //         boolean result = server_state.store.commit(txrecord);

    //         // for debug purposes
    //         System.out.println("Result is ready for request with reqid " + reqid);


    //         // create commit message to send to client
    //         DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
    //                 .setReqid(reqid).setAck(result).build();
    //         // send commit reply to client
    //         server_state.responseObserver.get(reqid).onNext(response);
    //         server_state.responseObserver.get(reqid).onCompleted();
    //         System.out.println("responded to client############");
    //         server_state.next_req += 1;
    //         reqid += 1;
    //     }
    // }
}
