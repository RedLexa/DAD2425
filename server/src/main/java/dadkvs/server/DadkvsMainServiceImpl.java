package dadkvs.server;

import java.util.ArrayList;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.util.CollectorStreamObserver;
import dadkvs.util.GenericResponseCollector;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

	DadkvsServerState server_state;
	DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_stubs;
	boolean stubs_created;
	int n_servers = 5;
	int config = 0; // config is 0 for now, when we add it we can change it

	public DadkvsMainServiceImpl(DadkvsServerState state) {
		this.server_state = state;
		this.stubs_created = false;
	}

	@Override
	public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
		// for debug purposes
		System.out.println("Receiving read request:" + request);

		int reqid = request.getReqid();
		int key = request.getKey();
		VersionedValue vv = this.server_state.store.read(key);

		DadkvsMain.ReadReply response = DadkvsMain.ReadReply.newBuilder()
				.setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		// this is used to create the stubs only once whenever all the servers are up,
		// its put here to avoid servers being down
		if (!stubs_created) {
			this.stubs_created = true;
			this.initComms();
		}
		// for debug purposes
		System.out.println("Receiving commit request:" + request);

		server_state.responseObserver.put(request.getReqid(), responseObserver);
		server_state.request_list.put(request.getReqid(), request);

		if (server_state.i_am_leader && !server_state.request_list.containsKey(request.getReqid())) {
			// comecar uma fase 1, olhando para o seu seq_number interno e verificando qual
			// deve o proximo index a executar, propondo-o dessa forma

			// server_state.req_to_propose = last_requestid_received; TO-DO: arranjar
			// maneira de saber sempre qual a transacao que o lider acha que devia ser
			// executada

			server_state.timestamp++;
			DadkvsPaxos.PhaseOneRequest.Builder phase_one_request = DadkvsPaxos.PhaseOneRequest.newBuilder();
			phase_one_request.setPhase1Config(this.config)
					.setPhase1Index(server_state.next_req)
					.setPhase1Timestamp(server_state.timestamp).build();
			// talvez esta logica daqui para baixo deva estar na parte do paxos?
			ArrayList<DadkvsPaxos.PhaseOneReply> phase_one_responses = new ArrayList<DadkvsPaxos.PhaseOneReply>();
			GenericResponseCollector<DadkvsPaxos.PhaseoneReply> phase_one_collector = new GenericResponseCollector<DadkvsPaxos.PhaseOneReply>(
					phase_one_responses, n_servers);
			for (int i = 0; i < n_servers; i++) {
				if (server_state.my_id == i) {
					// this.server_state.phase_two_requests.put(request.getReqid(),
					// phase_two_request.build());
					continue;
				}
				CollectorStreamObserver<DadkvsPaxos.PhaseOneReply> phase_one_observer = new CollectorStreamObserver<DadkvsPaxos.PhasOneReply>(
						phase_one_collector);
				async_stubs[i].phaseone(phase_one_request.build(), phase_one_observer);
			}
			int all_responses = n_servers - 1;
			phase_one_collector.waitForTarget(all_responses); //este wait deve estar errado, devemos ter de esperar em loop que so quebra quando temos maioria
			int accepts_needed = (n_servers / 2) + 1;
			int accepts_received = 0;
			int highest_received_timestamp = -1;
			if (phase_one_responses.size() >= accepts_needed) {
				// Iterate through all responses to count accepted ones
				for (DadkvsPaxos.PhaseOneReply phase_one_reply : phase_one_responses) {
					if (phase_one_reply.getPhase1Accepted()) {
						accepts_received++; // Count accepted responses
					}
					// You can also handle the timestamps here
					if (request.getValue() != -1 && request.getPhase1Accepted()) {
						if (highest_received_timestamp < request.getTimestamp()) {
							server_state.req_to_propose = request.getValue();
							highest_received_timestamp = request.getTimestamp();
						}

					} else if (!request.getPhase1Accepted()) {
						server_state.timestamp = request.getTimestamp();
						// acabas
					}
				}

				// After the loop, check if quorum is met
				if (accepts_received >= accepts_needed) {
					// Quorum reached: proceed to Phase Two with the most accepted value
					System.out.println("Quorum reached with " + accepts_received + " acceptances.");
					// Handle Phase Two proposal logic here
				} else {
					System.out.println("Not enough acceptances received. Total: " + accepts_received);
					// tentar outra vez? como?
				}
			} else
				System.out.println("Panic...error phase_one ing");
		}
	}

	private void initComms() {
		int n_servers = 5;
		String[] targets;
		targets = new String[n_servers];
		for (int i = 0; i < n_servers; i++) {
			int target_port = this.server_state.base_port + i;
			targets[i] = new String();
			targets[i] = "localhost" + ":" + target_port;
		}
		// Let us use plaintext communication because we do not have certificates
		ManagedChannel[] channels = new ManagedChannel[n_servers];

		for (int i = 0; i < n_servers; i++) {
			channels[i] = ManagedChannelBuilder.forTarget(targets[i]).usePlaintext().build();
		}

		async_stubs = new DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[n_servers];

		for (int i = 0; i < n_servers; i++) {
			async_stubs[i] = DadkvsPaxosServiceGrpc.newStub(channels[i]);
		}
	}
	public int getAgreedIndexOrDefault(int index) {
		return server_state.agreed_indexes.getOrDefault(index, -1);
	}
	// public static void executeCommit(int reqid, DadkvsServerState server_state){

    //     System.out.println("handle_all_possible_requests");
    //     System.out.println(server_state.next_req + "==" + reqid + "&&" + server_state.request_list.containsKey(reqid) + "&&" + server_state.phase_two_requests.containsKey(reqid));
    //     // enquanto o reqid for o do proximo pedido e se tivermos o pedido do cliente e do 2phase vamos processar a transacao
    //     while(server_state.request_list.containsKey(reqid) && server_state.phase_two_requests.containsKey(reqid) && server_state.phase_two_requests.get(reqid).getPhase2Value() == server_state.next_req) {

    //         DadkvsMain.CommitRequest request = server_state.request_list.get(reqid);
    //         DadkvsPaxos.PhaseTwoRequest p2request = server_state.phase_two_requests.get(reqid);
    //         int key1 = request.getKey1();
    //         int version1 = request.getVersion1();
    //         int key2 = request.getKey2();
    //         int version2 = request.getVersion2();
    //         int writekey = request.getWritekey();
    //         int writeval = request.getWriteval();

    //         // for debug purposes
    //         System.out.println("reqid " + reqid + " key1 " + key1 + " v1 " + version1 + " k2 " + key2 + " v2 " + version2 + " wk " + writekey + " writeval " + writeval);

    //         // append pedido a lista
    //         // this.timestamp++;  so interessa para o ldier
    //         TransactionRecord txrecord = new TransactionRecord(key1, version1, key2, version2, writekey, writeval, p2request.getPhase2Timestamp());
    //         boolean result = server_state.store.commit(txrecord);

    //         // for debug purposes
    //         System.out.println("Result is ready for request with reqid " + reqid);


    //         // create commit message to send to client
    //         DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
    //                 .setReqid(reqid).setAck(result).build();
    //         // send commit reply to client
    //         server_state.responseObserver.get(reqid).onNext(response);
    //         server_state.responseObserver.get(reqid).onCompleted();
    //         System.out.println("responded to client############");
    //         server_state.next_req += 1;
    //         reqid += 1;
    //     }
    // }
}
