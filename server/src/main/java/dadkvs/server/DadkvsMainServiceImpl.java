package dadkvs.server;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsMainServiceGrpc;
import java.util.ArrayList;

import dadkvs.util.GenericResponseCollector;
import dadkvs.util.CollectorStreamObserver;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;

import dadkvs.DadkvsPaxosServiceGrpc;
import io.grpc.stub.StreamObserver;
import java.util.Iterator;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;

	DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_stubs;
	boolean stubs_created;


    int               timestamp;
    int config = 0;   // config is 0 for now, when we add it we can change it
    public DadkvsMainServiceImpl(DadkvsServerState state) {
        this.server_state = state;
		this.timestamp = 0;
		this.stubs_created = false;
    }

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
	// for debug purposes
	System.out.println("Receiving read request:" + request);

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
	    .setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();
	
	responseObserver.onNext(response);
	responseObserver.onCompleted();
    }






    @Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		// TODO: add if para ver se tem um phase 2 do mesmo seq number para dar match


		// this is used to create the stubs only once whenever all the servers are up, its put here to avoid servers being down
		if(!stubs_created){
			this.stubs_created = true;
			this.initComms();
		}

		// for debug purposes
		System.out.println("Receiving commit request:" + request);

		// used to be able to reply to client once the commit message is processed(afer "consensus")
		server_state.responseObserver.put(request.getReqid(),responseObserver);
		// O request e adicionado depois para evitar varios requests iguais comecarem varias instancias de consenso


		// se for o lider e nao tiver o valor na queue
		// sistema de locks? tem que ser feito syncronize
		if(server_state.i_am_leader && !server_state.request_list.containsKey(request.getReqid())){
			// acrescenta o request a hash table
			server_state.request_list.put(request.getReqid(),request);
			// incrementa o timestamp
			this.timestamp++;  // 1 -> 2 -> 3 -> 4
			// cria a mensagem da phase 2
			DadkvsPaxos.PhaseTwoRequest.Builder phase_two_request = DadkvsPaxos.PhaseTwoRequest.newBuilder();
				phase_two_request.setPhase2Config(this.config)
						.setPhase2Index(request.getReqid())
						.setPhase2Value(this.timestamp)
						.setPhase2Timestamp(this.timestamp).build();


			int n_servers = 5;


			// coisas que deviam estar numa funcao para enviar mensagens e esperar receber respostas, tudo copiado e adaptado do client
			ArrayList<DadkvsPaxos.PhaseTwoReply> phase_two_responses = new ArrayList<DadkvsPaxos.PhaseTwoReply>();
			GenericResponseCollector<DadkvsPaxos.PhaseTwoReply> phase_two_collector = new GenericResponseCollector<DadkvsPaxos.PhaseTwoReply> (phase_two_responses, n_servers);

			for (int i = 0; i < n_servers; i++) {
				CollectorStreamObserver<DadkvsPaxos.PhaseTwoReply> phase_two_observer = new CollectorStreamObserver<DadkvsPaxos.PhaseTwoReply>(phase_two_collector);
				async_stubs[i].phasetwo(phase_two_request.build(), phase_two_observer);
			}

			int responses_needed = n_servers;  // aqui disse que o lider espera receber mensagens de todos, no futuro sera da maioria acho eu
			phase_two_collector.waitForTarget(responses_needed);
			if (phase_two_responses.size() >= responses_needed) {
				Iterator<DadkvsPaxos.PhaseTwoReply> phase_two_iterator = phase_two_responses.iterator();
				DadkvsPaxos.PhaseTwoReply phase_two_reply = phase_two_iterator.next ();
				System.out.println("Reqid = " + request.getReqid() + " index in reply = " + phase_two_reply.getPhase2Index());
				boolean result = phase_two_reply.getPhase2Accepted();
				if (result) {
					System.out.println("phase_two index " + phase_two_request.getPhase2Index() + " with value " + phase_two_request.getPhase2Value());
				} else {
					System.out.println("phase_two Failed");
				}
			}
			else
				System.out.println("Panic...error phase_two ing");
		}
		else{
			server_state.request_list.put(request.getReqid(),request);
		}

    }
	//received seq number
	//colocar o pedido de maneira ordenada num tree map, associado ao req id
	// dependendo do tipo de pedido de recebeste, vais ver de que tipo Ã© na array list



	// server para inciar os stubs basicamente, igual ao do client mas tmb faco os enderecos ai pq faz mais sentido
	private void initComms () {
		int n_servers = 5;
		String[] targets;
		targets = new String[n_servers];
		for (int i = 0; i < n_servers; i++) {
			int target_port = this.server_state.base_port +i;
			targets[i] = new String();
			targets[i] = "localhost" + ":" + target_port;
		}
		// Let us use plaintext communication because we do not have certificates
		ManagedChannel[] channels = new ManagedChannel[n_servers];

		for (int i = 0; i < n_servers; i++) {
			channels[i] = ManagedChannelBuilder.forTarget(targets[i]).usePlaintext().build();
		}

		async_stubs = new DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[n_servers];

		for (int i = 0; i < n_servers; i++) {
			async_stubs[i] = DadkvsPaxosServiceGrpc.newStub(channels[i]);
		}
	}
}
