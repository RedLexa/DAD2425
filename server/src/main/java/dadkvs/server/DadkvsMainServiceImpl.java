package dadkvs.server;

import java.util.ArrayList;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.CollectorStreamObserver;
import dadkvs.util.GenericResponseCollector;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

	DadkvsServerState server_state;
	static DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_stubs;
	boolean stubs_created;
	int n_servers = 5;
	int config = 0; // config is 0 for now, when we add it we can change it

	public DadkvsMainServiceImpl(DadkvsServerState state) {
		this.server_state = state;
		this.stubs_created = false;
	}

	@Override
	public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
		// for debug purposes
		System.out.println("Receiving read request:" + request);

		int reqid = request.getReqid();
		int key = request.getKey();
		VersionedValue vv = this.server_state.store.read(key);

		DadkvsMain.ReadReply response = DadkvsMain.ReadReply.newBuilder()
				.setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	public boolean get_lock() {
		if(this.server_state.locked){
			return false;
		}
		this.server_state.locked = true;
		return true;
	}

	@Override
	public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {
		// Make sure no other thread running
		// Necessary for this phase of implementation

		//notify this.server_state.dowork

		if(this.server_state.i_am_leader){
			// only one commit at a time for the leader
			synchronized(this){
				while(this.get_lock() == false){
					System.out.println("Waiting for consensus to finish");
					try {
						wait();
					} catch (InterruptedException e) {
						Thread.currentThread().interrupt(); 
						System.err.println("Thread Interrupted");
					}
				}
			}
		}


		System.out.println("Starting consensus ...");
		// this is used to create the stubs only once whenever all the servers are up,
		// its put here to avoid servers being down
		if (!stubs_created) {
			this.stubs_created = true;
			this.initComms();
		}

		int accepts_received = 0; // declaro isto aqui em cima por questoes de scope
		// for debug purposes
		//System.out.println("Receiving commit request:" + request);

		server_state.responseObserver.put(request.getReqid(), responseObserver);
		server_state.request_list.put(request.getReqid(), request);

		if (server_state.i_am_leader && server_state.request_list.containsKey(request.getReqid())) {
			System.out.println("SOU O LIDER #################");
			// comecar uma fase 1, olhando para o seu seq_number interno e verificando qual
			// deve o proximo index a executar, propondo-o dessa forma

			server_state.req_to_propose = request.getReqid(); //aqui devia ser a ultima request q recebemos
			// maneira de saber sempre qual a transacao que o lider acha que devia ser
			// executada

			server_state.timestamp++;
			//System.out.println("Starting phase 1 with index " + server_state.next_req + " and timestamp "
					//+ server_state.timestamp);
			boolean you_shall_not_pass = true;
			int all_responses = n_servers; 
			int accepts_needed = (n_servers / 2 + 1); // maioria considerando o nosso proprio pedido
			int messages_needed = accepts_needed;
			while(you_shall_not_pass) {
				you_shall_not_pass = false;
				int highest_received_timestamp = -1;
				DadkvsPaxos.PhaseOneRequest.Builder phase_one_request = DadkvsPaxos.PhaseOneRequest.newBuilder();
				phase_one_request.setPhase1Config(this.config)
						.setPhase1Index(this.server_state.next_req) // seq num
						.setPhase1Timestamp(this.server_state.timestamp).build();
				// talvez esta logica daqui para baixo deva estar na parte do paxos?
				ArrayList<DadkvsPaxos.PhaseOneReply> phase_one_responses = new ArrayList<DadkvsPaxos.PhaseOneReply>();
				GenericResponseCollector<DadkvsPaxos.PhaseOneReply> phase_one_collector = new GenericResponseCollector<DadkvsPaxos.PhaseOneReply>(
						phase_one_responses, n_servers);
				for (int i = 0; i < n_servers; i++) {
					CollectorStreamObserver<DadkvsPaxos.PhaseOneReply> phase_one_observer = new CollectorStreamObserver<DadkvsPaxos.PhaseOneReply>(
							phase_one_collector);
					async_stubs[i].phaseone(phase_one_request.build(), phase_one_observer);
				}

				all_responses = n_servers - 1; 
				accepts_needed = (n_servers / 2 + 1); // maioria considerando o nosso proprio pedido
				messages_needed = accepts_needed;

				phase_one_collector.waitForTarget(accepts_needed);  
				
				for (DadkvsPaxos.PhaseOneReply phase_one_reply : phase_one_responses) {
					if (phase_one_reply.getPhase1Accepted()) {
						accepts_received++; // Count accepted responses
					}
					else{ 
						if(this.server_state.timestamp <= phase_one_reply.getPhase1Timestamp()){
							this.server_state.timestamp = phase_one_reply.getPhase1Timestamp()+1;
							you_shall_not_pass = true;
						}
					}
					if (phase_one_reply.getPhase1Value() != -1) {
						if (highest_received_timestamp < phase_one_reply.getPhase1Timestamp()) {
							server_state.req_to_propose = phase_one_reply.getPhase1Value();
							highest_received_timestamp = phase_one_reply.getPhase1Timestamp();
						}
					}
				}
			}
			System.out.println("Phase 1 Quorum reached with " + accepts_received + " acceptances.");


			// Phase Two
			// avancar para fase 2 com o meu valor ou o valor q me foi dado pelos accepts
			you_shall_not_pass = true;
			while(you_shall_not_pass) {
				System.out.println("preso aqui???");
				you_shall_not_pass = false;
				DadkvsPaxos.PhaseTwoRequest.Builder phase_two_request = DadkvsPaxos.PhaseTwoRequest.newBuilder();
				phase_two_request.setPhase2Config(this.config)
						.setPhase2Index(server_state.next_req)
						.setPhase2Value(server_state.req_to_propose)
						.setPhase2Timestamp(server_state.timestamp).build();
				ArrayList<DadkvsPaxos.PhaseTwoReply> phase_two_responses = new ArrayList<DadkvsPaxos.PhaseTwoReply>();
				GenericResponseCollector<DadkvsPaxos.PhaseTwoReply> phase_two_collector = new GenericResponseCollector<DadkvsPaxos.PhaseTwoReply>(
						phase_two_responses, n_servers);
				for (int i = 0; i < n_servers; i++) {
					CollectorStreamObserver<DadkvsPaxos.PhaseTwoReply> phase_two_observer = new CollectorStreamObserver<DadkvsPaxos.PhaseTwoReply>(
							phase_two_collector);
					async_stubs[i].phasetwo(phase_two_request.build(), phase_two_observer);
				}
				accepts_received = 0;
				messages_needed = accepts_needed;

				phase_two_collector.waitForTarget(messages_needed);

				for (DadkvsPaxos.PhaseTwoReply phase_two_reply : phase_two_responses) {
					if (phase_two_reply.getPhase2Accepted()) {
						accepts_received++; // Count accepted responses
					}
					else{
						you_shall_not_pass = true;
					}
				}
			}


			// Learning Phase
			System.out.println("Phase 2 Quorum reached with " + accepts_received + " acceptances.");
			//server_state.agreed_indexes.put(server_state.next_req, server_state.req_to_propose); // marcar como
			/*																					// guardado
			DadkvsPaxos.LearnRequest.Builder learn_request = DadkvsPaxos.LearnRequest.newBuilder();
			learn_request.setLearnconfig(this.config)
					.setLearnindex(server_state.next_req)
					.setLearnvalue(server_state.req_to_propose)
					.setLearntimestamp(server_state.timestamp).build();
			ArrayList<DadkvsPaxos.LearnReply> learn_responses = new ArrayList<DadkvsPaxos.LearnReply>();
			GenericResponseCollector<DadkvsPaxos.LearnReply> learn_collector = new GenericResponseCollector<DadkvsPaxos.LearnReply>(
					learn_responses, n_servers);
			for (int i = 0; i < n_servers; i++) {
				CollectorStreamObserver<DadkvsPaxos.LearnReply> learn_observer = new CollectorStreamObserver<DadkvsPaxos.LearnReply>(
						learn_collector);
				async_stubs[i].learn(learn_request.build(), learn_observer);
			}
			accepts_received = 0;
			messages_needed = accepts_needed;
			while (accepts_received < accepts_needed) {
				accepts_received = 0; // podemos mudar a logica mas fiz so copy paste
				learn_collector.waitForTarget(messages_needed);
				for (DadkvsPaxos.LearnReply learn_reply : learn_responses) {
					if (learn_reply.getLearnaccepted()) {
						accepts_received++; // Count accepted responses
					}
				}
				messages_needed = messages_needed + accepts_needed - accepts_received;
				// se recebemos um quorum de mensagens e do quorum de mensagens ainda faltam
				// (accepts needed - accepts recieved) accepts -> precisamos de esperar por mais
				// esse numero de mensagens
			}*/
			System.out.println("Learn Quorum reached with " + accepts_received + " acceptances.");
			//executeCommits(server_state);
			//executeCommit(server_state.req_to_propose, server_state);
			synchronized (this) {
				this.server_state.next_req++;
				this.server_state.locked = false;   // destranca o consensus e notifica os outros threads
				notifyAll();
			}
			
		} 

	}

	private void initComms() {
		int n_servers = 5;
		String[] targets;
		targets = new String[n_servers];
		for (int i = 0; i < n_servers; i++) {
			int target_port = this.server_state.base_port + i;
			targets[i] = new String();
			targets[i] = "localhost" + ":" + target_port;
		}
		// Let us use plaintext communication because we do not have certificates
		ManagedChannel[] channels = new ManagedChannel[n_servers];

		for (int i = 0; i < n_servers; i++) {
			channels[i] = ManagedChannelBuilder.forTarget(targets[i]).usePlaintext().build();
		}

		async_stubs = new DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[n_servers];

		for (int i = 0; i < n_servers; i++) {
			async_stubs[i] = DadkvsPaxosServiceGrpc.newStub(channels[i]);
		}
	}


	public static void executeCommits(DadkvsServerState server_state) {
		// for debug purposes
		System.out.println("Executing all commits");
		// tem que existir um pedido do cliente, um pedido phase 2 e uma maioria de learns da timestamp
		
		while(server_state.agreed_indexes.containsKey(server_state.next_req) && 
			server_state.agreed_indexes.get(server_state.next_req) != null &&
			server_state.learn_counter.getOrDefault(server_state.agreed_indexes.get(server_state.next_req).getPhase2Timestamp(), 0) >= 3 &&
			server_state.request_list.containsKey(server_state.agreed_indexes.get(server_state.next_req).getPhase2Value())){
			// executa commit
			System.out.println("Executing commit with reqid " + server_state.next_req + "###########################################");
			executeCommit(server_state.agreed_indexes.get(server_state.next_req).getPhase2Value(), server_state);
			server_state.next_req++;
		}
	}

	public static void executeCommit(int reqid, DadkvsServerState server_state) {
		int n_servers = 5;

		System.out.println("executing transaction with reqid " + reqid);
		System.out.println("next_req is " + server_state.next_req);
		// enquanto o reqid for o do proximo pedido e se tivermos o pedido do cliente
		// e do 2phase vamos processar a transacao

		DadkvsMain.CommitRequest request = server_state.request_list.get(reqid);
		int key1 = request.getKey1();
		int version1 = request.getVersion1();
		int key2 = request.getKey2();
		int version2 = request.getVersion2();
		int writekey = request.getWritekey();
		int writeval = request.getWriteval();

		// for debug purposes
		System.out.println("reqid " + reqid + " key1 " + key1 + " v1 " + version1 + "k2"
				+ key2 + " v2 " + version2 + " wk " + writekey + " writeval " +
				writeval);

		// append pedido a lista
		// this.timestamp++; so interessa para o ldier
		TransactionRecord txrecord = new TransactionRecord(key1, version1, key2,
				version2, writekey, writeval, server_state.timestamp);
		boolean result = server_state.store.commit(txrecord);

		// for debug purposes
		System.out.println("Result is ready for request with reqid " + reqid);

		// create commit message to send to client
		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
				.setReqid(reqid).setAck(result).build();
		// send commit reply to client
		server_state.responseObserver.get(reqid).onNext(response);
		server_state.responseObserver.get(reqid).onCompleted();
		System.out.println("responded to client############");
	}

	public static void send_learn_requests(DadkvsPaxos.PhaseTwoRequest request){
		int n_servers = 5;
		DadkvsPaxos.LearnRequest.Builder learn_request = DadkvsPaxos.LearnRequest.newBuilder();
		learn_request.setLearnconfig(request.getPhase2Config())
					.setLearnindex(request.getPhase2Index())
					.setLearnvalue(request.getPhase2Value())
					.setLearntimestamp(request.getPhase2Timestamp()).build();


		ArrayList<DadkvsPaxos.LearnReply> learn_responses = new ArrayList<DadkvsPaxos.LearnReply>();
		GenericResponseCollector<DadkvsPaxos.LearnReply> learn_collector = new GenericResponseCollector<DadkvsPaxos.LearnReply>(
				learn_responses, n_servers);

		for (int i = 0; i < n_servers; i++) {
			CollectorStreamObserver<DadkvsPaxos.LearnReply> learn_observer = new CollectorStreamObserver<DadkvsPaxos.LearnReply>(
					learn_collector);
			async_stubs[i].learn(learn_request.build(), learn_observer);
		}
		int accepts_received = 0;
		int accepts_needed = (n_servers / 2 + 1); // maioria considerando o nosso proprio pedido
		int messages_needed = accepts_needed;
		learn_collector.waitForTarget(messages_needed);
		System.out.println("Sent Learn");
	}
}
